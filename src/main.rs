use std::path::PathBuf;

use gtk::prelude::{BoxExt, ButtonExt, GridExt, GtkWindowExt, OrientableExt};
use relm4::factory::positions::GridPosition;
use relm4::factory::{
    DynamicIndex, FactoryComponent, FactoryComponentSender, FactoryVecDeque, Position,
};
use relm4::gtk::traits::WidgetExt;
use relm4::{gtk, ComponentParts, ComponentSender, RelmApp, SimpleComponent, WidgetPlus};

#[derive(Debug)]
struct PictureComponent {
    path: PathBuf,
}

#[derive(Debug)]
enum CounterMsg {
    Increment,
    Decrement,
}

#[derive(Debug)]
enum CounterOutput {
    SendFront(DynamicIndex),
    MoveUp(DynamicIndex),
    MoveDown(DynamicIndex),
}

struct PictureWidgets {
    image: gtk::Picture,
}

impl Position<GridPosition> for PictureComponent {
    fn position(index: usize) -> GridPosition {
        let x = index % 4;
        let y = index / 4;
        GridPosition {
            column: x as i32,
            row: y as i32,
            width: 1,
            height: 1,
        }
    }
}

impl FactoryComponent for PictureComponent {
    type CommandOutput = ();
    type Init = PathBuf;
    type Input = ();
    type Output = ();
    type ParentInput = AppMsg;
    type ParentWidget = gtk::Grid;
    type Root = gtk::Box;
    type Widgets = PictureWidgets;

    fn output_to_parent_input(_output: Self::Output) -> Option<AppMsg> {
        None
    }

    fn init_root(&self) -> Self::Root {
        relm4::view! {
            root = gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 10,
            }
        }
        root
    }

    fn init_model(
        value: Self::Init,
        _index: &DynamicIndex,
        _sender: FactoryComponentSender<Self>,
    ) -> Self {
        Self { path: value }
    }

    fn init_widgets(
        &mut self,
        _index: &DynamicIndex,
        root: &Self::Root,
        _returned_widget: &gtk::Widget,
        _sender: FactoryComponentSender<Self>,
    ) -> Self::Widgets {
        relm4::view! {
            image = gtk::Picture {
                set_filename: self.path.to_str(),
                set_keep_aspect_ratio: true,
                set_can_shrink: false,
            }
        }

        relm4::view! {
            label = gtk::Label {
                set_label: &self.path.to_str().unwrap(),
                // set_keep_aspect_ratio: true,
                // set_can_shrink: true,
            }
        }

        root.append(&image);
        // root.append(&label);

        PictureWidgets { image }
    }

    fn update(&mut self, _msg: Self::Input, _sender: FactoryComponentSender<Self>) {}

    fn update_view(&self, widgets: &mut Self::Widgets, _sender: FactoryComponentSender<Self>) {
        widgets.image.set_filename(Some(&self.path));
    }
}

struct AppModel {
    pictures: FactoryVecDeque<PictureComponent>,
}

#[derive(Debug)]
enum AppMsg {
    AddImage(PathBuf),
}

#[relm4::component]
impl SimpleComponent for AppModel {
    type Init = Vec<PathBuf>;
    type Input = AppMsg;
    type Output = ();
    // AppWidgets is generated by the macro
    type Widgets = AppWidgets;

    view! {
        gtk::ApplicationWindow {
            set_title: Some("Grid factory example"),
            set_default_width: 300,
            set_default_height: 100,

            gtk::ScrolledWindow{
                set_hscrollbar_policy: gtk::PolicyType::Never,
                set_min_content_height: 360,
                set_vexpand: true,

                gtk::Box {
                    append: picture_box = &gtk::Grid {
                        set_orientation: gtk::Orientation::Vertical,
                        set_column_spacing: 15,
                        set_row_spacing: 5,
                    }
                }
            }
        }
    }

    // Initialize the UI.
    fn init(
        paths: Self::Init,
        root: &Self::Root,
        sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        // Insert the macro codegen here
        let widgets = view_output!();

        let mut model = AppModel {
            pictures: FactoryVecDeque::new(widgets.picture_box.clone(), sender.input_sender()),
        };

        {
            let mut picture_guard = model.pictures.guard();
            for p in paths {
                picture_guard.push_back(p);
            }
        }

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, _sender: ComponentSender<Self>) {
        let mut picture_guard = self.pictures.guard();
        match msg {
            AppMsg::AddImage(p) => {
                picture_guard.push_back(p);
            }
        }
    }
}

fn main() {
    let app = RelmApp::new("relm4.example.gridFactory");
    let mut images =
        vec![PathBuf::from("/Users/malcolm/Projects/decimator-relm4/picture.jpg",); 100];
    images.insert(0, PathBuf::from("./image.png"));

    app.run::<AppModel>(images)
}
